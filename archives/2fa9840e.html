<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="baidu-site-verification" content="code-oy2gTeqH9v" />
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/blogIcon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blogIcon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blogIcon.png">
  <link rel="mask-icon" href="/images/blogIcon.png" color="#222">
  <link rel="manifest" href="/images/blogIcon.png">
  <meta name="google-site-verification" content="5O1JD7i07BBNtPS8GeMREfy3KlJKyIHRvUbt0Ulnc4k">
  <meta name="msvalidate.01" content="defbadb89c5687f86ead63be53a1b83c">
  <meta name="baidu-site-verification" content="kBCDbEEWrIWKXwYW">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css">
  <script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ychch.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="网络基础知识">
<meta property="og:url" content="https://ychch.top/archives/2fa9840e.html">
<meta property="og:site_name" content="CYC&#39;s 个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/12/14/Op8ZBRauxcdk7qw.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/14/ml2YRGZ3D7WHLEx.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/14/6xzDZsWJcOkyj12.webp">
<meta property="og:image" content="https://s2.loli.net/2022/10/14/kGpiKSqWLAdHolu.png">
<meta property="og:image" content="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125203116958.webp">
<meta property="og:image" content="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125204137979.webp">
<meta property="og:image" content="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125205025638.webp">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604070508591-32d79893-7e98-40c8-b779-ffb6da42cd1b.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/08/Rg5AaQuisDjmebS.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image/resize,w_1500">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/13/uwXdpFOnlC4D5rt.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/13/6inOkuYDK5FRg2P.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/13/pC9ZO4gBdYjhIqR.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/15/teDAv2bXn1LhSWc.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/05/yT9ds8Rpb2mN6cL.png">
<meta property="og:image" content="https://s2.loli.net/2022/12/05/Kd3qCfVzD6E9QbA.png">
<meta property="article:published_time" content="2022-10-13T12:42:51.000Z">
<meta property="article:modified_time" content="2024-08-20T01:48:22.990Z">
<meta property="article:author" content="ych-ch">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/12/14/Op8ZBRauxcdk7qw.png">


<link rel="canonical" href="https://ychch.top/archives/2fa9840e.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ychch.top/archives/2fa9840e.html","path":"archives/2fa9840e.html","title":"网络基础知识"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>网络基础知识 | CYC's 个人博客</title>
  




<link rel="dns-prefetch" href="https://comment.ychch.top/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="CYC's 个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CYC's 个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">当我与世界初相见</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>我 & 友链</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">60</span></a></li>
        <li class="menu-item menu-item-pictures"><a href="/gallery/" rel="section"><i class="fa fa-images fa-fw"></i>影像馆</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>光影岁月</a></li>
        <li class="menu-item menu-item-shuoshuo"><a href="/shuoshuo/" rel="section"><i class="fa fa-comment fa-fw"></i>只言片语</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">五层网络体系结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E4%B8%8EUDP"><span class="nav-number">2.</span> <span class="nav-text">TCP与UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">2.1.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-number">2.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E9%9D%A0"><span class="nav-number">2.4.</span> <span class="nav-text">UDP协议为什么不可靠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.5.</span> <span class="nav-text">TCP的三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.5.2.</span> <span class="nav-text">四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2%EF%BC%9F"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">那为什么需要四次挥手呢？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.6.</span> <span class="nav-text">TCP的重传机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.7.</span> <span class="nav-text">TCP的拥塞控制机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="nav-number">2.7.1.</span> <span class="nav-text">慢启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">2.7.2.</span> <span class="nav-text">拥塞避免</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="nav-number">2.7.3.</span> <span class="nav-text">快速重传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="nav-number">2.7.4.</span> <span class="nav-text">快速恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">2.8.</span> <span class="nav-text">TCP的流量控制机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="nav-number">2.9.</span> <span class="nav-text">TCP的可靠传输机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.</span> <span class="nav-text">HTTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">常见的HTTP请求方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="nav-number">3.2.</span> <span class="nav-text">GET和POST的请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POST%E5%92%8CPUT%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">POST和PUT请求的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-0-%E3%80%811-1-%E5%92%8C-2-0"><span class="nav-number">3.4.</span> <span class="nav-text">HTTP 1.0 、1.1 和  2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-0%E5%92%8C-HTTP-1-1-%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.1.</span> <span class="nav-text">HTTP 1.0和 HTTP 1.1 有以下区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%92%8C%E9%98%9F%E5%A4%B4%E5%A0%B5%E5%A1%9E"><span class="nav-number">3.4.2.</span> <span class="nav-text">管道网络传输和队头堵塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-1-%E5%92%8C-HTTP-2-0-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.3.</span> <span class="nav-text">HTTP 1.1 和 HTTP 2.0 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#keep-alive"><span class="nav-number">3.4.4.</span> <span class="nav-text">keep-alive</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8BKeep-Alive"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">如何建立Keep-Alive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%EF%BC%9F"><span class="nav-number">3.4.5.</span> <span class="nav-text">HTTP如何加载页面的多张图片？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP2%E7%9A%84%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95HPACK"><span class="nav-number">3.4.6.</span> <span class="nav-text">HTTP2的头部压缩算法HPACK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">3.5.</span> <span class="nav-text">HTTP请求报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">3.6.</span> <span class="nav-text">HTTP响应报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.7.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.8.</span> <span class="nav-text">HTTP协议的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.9.</span> <span class="nav-text">HTTP和HTTPS协议的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTPS"><span class="nav-number">4.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TLS-SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">TLS&#x2F;SSL的工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.1.</span> <span class="nav-text">散列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">4.1.2.</span> <span class="nav-text">对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">4.1.3.</span> <span class="nav-text">非对称加密</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="nav-number">4.2.</span> <span class="nav-text">数字证书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8"><span class="nav-number">4.3.</span> <span class="nav-text">HTTPS如何保证安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">HTTPS通信过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS%E7%89%B9%E7%82%B9"><span class="nav-number">4.5.</span> <span class="nav-text">HTTPS特点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-Google-com-%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">在浏览器中输入 Google.com 后发生了什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#URI"><span class="nav-number">6.</span> <span class="nav-text">URI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D%E6%91%B8%E7%B4%A2%E4%B9%8B%E8%B7%AF"><span class="nav-number">6.1.</span> <span class="nav-text">域名摸索之路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">DNS解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.1.</span> <span class="nav-text">DNS同时使用TCP和UDP协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">DNS完整的查询过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2%E4%B8%8E%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.3.</span> <span class="nav-text">迭代查询与递归查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS-%E8%AE%B0%E5%BD%95%E5%92%8C%E6%8A%A5%E6%96%87"><span class="nav-number">7.4.</span> <span class="nav-text">DNS 记录和报文</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebSocket"><span class="nav-number">8.</span> <span class="nav-text">WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%9F%AD%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2%E3%80%81SSE-%E5%92%8C-WebSocket-%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">8.1.1.</span> <span class="nav-text">短轮询的基本思路：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="nav-number">8.1.2.</span> <span class="nav-text">长轮询的基本思路：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSE-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">8.1.3.</span> <span class="nav-text">SSE 的基本思想：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-1"><span class="nav-number">8.1.4.</span> <span class="nav-text">WebSocket</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ych-ch"
      src="/images/bird-in-snow.webp">
  <p class="site-author-name" itemprop="name">ych-ch</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ych-chen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ych-chen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2021206190014@whu.edu.cn" title="E-Mail → mailto:2021206190014@whu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



        </div>
      </div>

+     <div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>     
 
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ychch.top/archives/2fa9840e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bird-in-snow.webp">
      <meta itemprop="name" content="ych-ch">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYC's 个人博客">
      <meta itemprop="description" content="个人博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="网络基础知识 | CYC's 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          网络基础知识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-10-13 20:42:51" itemprop="dateCreated datePublished" datetime="2022-10-13T20:42:51+08:00">2022-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-20 09:48:22" itemprop="dateModified" datetime="2024-08-20T09:48:22+08:00">2024-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">前端开发</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/archives/2fa9840e.html#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/archives/2fa9840e.html" data-xid="/archives/2fa9840e.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img data-src="https://s2.loli.net/2022/12/14/Op8ZBRauxcdk7qw.png"></p>
<span id="more"></span>

<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p><img data-src="https://s2.loli.net/2022/12/14/ml2YRGZ3D7WHLEx.png" alt="计算机网络结构"></p>
<ul>
<li><code>OSI体系结构</code>: 概念清楚，理论也比较完整，但复杂不实用。</li>
<li><code>TCP/IP体系结构</code>:TCP/IP是一个四层体系结构，得到了广泛的运用。</li>
<li><code>五层体系结构</code>:  折中<code>OSI体系结构</code>和<code>TCP/IP体系结构</code>，综合二者的优点，这样既简洁，又能将概念讲清楚。</li>
</ul>
<h2 id="五层网络体系结构"><a href="#五层网络体系结构" class="headerlink" title="五层网络体系结构"></a><strong>五层网络体系结构</strong></h2><p><code>应用层</code>：应用层是网络协议的最高层，主要任务<strong>通过进程间的交互完成特定网络应用</strong>。应用层协议定义的是<code>应用程序（进程）间通信和交互的规则</code>。如 DNS、HTTP、SMTP…</p>
<p><code>运输层</code>：有时也译为传输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</p>
<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供<strong>面向连接的</strong>、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
<p><code>网络层</code>：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成<code>分组</code>或 <code>包</code>进行传送。</p>
<p><code>数据链路层</code>：简称为<code>链路层</code>。在两个相邻节点传输数据时，将网络层交下来的IP数据报<code>组装成帧</code>，在两个相邻节点之间的链路上传送<code>帧</code>。</p>
<p><code>物理层</code>：保证数据可以在各种物理媒介上进行传输</p>
<p><img data-src="https://s2.loli.net/2022/12/14/6xzDZsWJcOkyj12.webp" alt="三层模型对比"></p>
<h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h1><p>TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP，<strong>transmission control protocol 传输控制协议</strong>，</p>
<p>一种面向连接的，可靠的，基于字节流的传输层通信协议，数据传输单位是 报文段，建立连接的过程就是三次握手。</p>
<ol>
<li>面向连接。三次握手 建立可靠连接</li>
<li>仅支持单播传输。只能1对1</li>
<li>面向字节流</li>
<li>可靠传输。TCP给每个包一个序号，也保证了按序接收。接收端实体对已成功收到的字节发回一个相应的确认(ACK)；在合理的往返时延(RTT)内未收到确认，那么对应的数据将会被重传</li>
<li>提供拥塞控制。当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</li>
</ol>
<p><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。文件传输、接受邮件、远程登录。</p>
<p><img data-src="https://s2.loli.net/2022/10/14/kGpiKSqWLAdHolu.png" alt="image-20221014142705409"></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><strong>user data protocol 用户数据报协议</strong>，喇叭喊人，数据传输单位是 用户数据报。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<ol>
<li><strong>面向无连接</strong>。不需要三次握手建立连接，想发数据随时发，不会对数据报文进行拆分和拼接操作</li>
<li><strong>有单播，多播，广播的功能</strong>。</li>
<li><strong>面向报文</strong>。UDP对应用层交下来的报文，既不合并，也不拆分。因此，应用程序必须选择合适大小的报文</li>
<li><strong>不可靠性</strong>。不会备份数据，不关心对方是否已经正确接收</li>
<li><strong>头部开销小，传输数据报文时是很高效</strong>。UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多。在传输数据报文时是很高效的。</li>
</ol>
<p><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话、广播通信（广播、多播）。</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p>字节就是散乱的数据 报文就是添加了标记，封装后的数据</p>
<h2 id="UDP协议为什么不可靠"><a href="#UDP协议为什么不可靠" class="headerlink" title="UDP协议为什么不可靠"></a>UDP协议为什么不可靠</h2><ol>
<li>不保证消息交付</li>
<li>不保证交付顺序</li>
<li>不跟踪连接状态</li>
<li>不进行拥塞控制</li>
</ol>
<h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img data-src="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125203116958.webp" alt="image-20230125203116958"></p>
<p>三次握手，指建立一个TCP连接时，需要客户端和服务器总共发送3个包。主要作用就是为了<strong>确认双方的接收能力和发送能力是否正常</strong>、同步连接双方的序列号和确认号，交换TCP窗口大小信息  为后面的可靠性传送做准备。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 seq = x ，此时客户端处于 SYN_SEND 状态。</li>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 seq = y。同时会把客户端的 seq  + 1 即 x + 1作为ACK 的值，表示已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 seq  + 1 即 y + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<p><strong>为了防止已失效的连接请求报文段突然又传送到了服务端，造成双方的不一致，导致资源的浪费</strong></p>
<p>客户端发出一个SYN报文段，由于阻塞或者其他原因在网络中滞留，以至于客户端认为丢包了（其实并没有丢），于是重新发出一个SYN报文段，假设这一次顺利完成了，那么双方建立连接。</p>
<p>这看起来似乎没什么问题，但网络中有一个隐患，就是那个还在网络中传输的SYN报文段，如果这个SYN在连接期间被服务端收到了，那服务端只会无视它，这样就万事大吉了，<strong>但如果是在连接释放之后被收到呢？</strong>此时服务端认为有人向他发出连接请求，于是响应一个SYNACK回去，如果采用两次握手的话，那么服务器认为此时连接已经建立好了。但是当客户端收到这个SYNACK时，如果他并没有发起连接，那么他不会理睬这个SYNACK，就当没事发生过（如果客户端此时正好发起连接，那其实他也不会理睬这个SYNACK，因为确认号不对啊。）。那问题就大了，这时候服务器以为连接好了，向客户端发送数据，而客户端处于CLOSED状态，会丢弃这些包，这样就很浪费了。并且还有一个尴尬的问题，就是这个时候当客户端打算发起连接时，服务端又不理睬了，在这里尬这，他们就别想互发数据了。当然这些问题似乎不是不可解决的，当客户端发现服务端老是向自己发数据，而自己总是丢弃，可能会向服务端发一个RST（报文段的RST标记号为1），强制服务端关闭连接。但资源总归是浪费了一会了。而用三次握手就不会出现这样的问题。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img data-src="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125204137979.webp" alt="image-20230125204137979"></p>
<p>男：“我觉得我们可能不太合适，我们分手吧，我不会再主动联系你。”（发出关闭连接的请求）<br>女：“你要分手，可以，但是我还没做好心理准备，可以让我再跟你说多几句话吗？”（发出ACK报文段）<br>（此后男生不会再主动联系女生，而女生还会联系男生）<br>女：“好，我该说的话都说完了，我们好聚好散吧。”（发送关闭连接的报文段）<br>男：“再见。”（发出ACK报文段，让女生知道我已经收到了）<br>（女生收到后，放下了男生，即释放了资源）<br>（男生在等待一段时间后，女生没有再回信，男生就默认女生已经收到最后的告别信了，于是放下女生，即释放了资源，从此不相往来（除非复合，即重新建立连接））</p>
<p>不开玩笑：</p>
<ul>
<li><strong>第一次挥手</strong>：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明<strong>客户端到服务端的连接已经释放</strong>，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，<strong>但是服务端仍旧可以发送数据给客户端</strong>。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会<strong>向客户端发送连接释放请求</strong>，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次挥手</strong>：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>
<h4 id="那为什么需要四次挥手呢？"><a href="#那为什么需要四次挥手呢？" class="headerlink" title="那为什么需要四次挥手呢？"></a>那为什么需要四次挥手呢？</h4><p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<h2 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h2><p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该数据进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<h2 id="TCP的拥塞控制机制"><a href="#TCP的拥塞控制机制" class="headerlink" title="TCP的拥塞控制机制"></a>TCP的拥塞控制机制</h2><p>TCP的拥塞控制机制主要是以下四种机制：慢启动、拥塞避免、快速重传、快速恢复</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要<strong>连续收到三个重复确认</strong>就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>由于不需要等待设置的重传计时器到期，能尽早重传，能提高整个网络的吞吐量</p>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><h2 id="TCP的流量控制机制"><a href="#TCP的流量控制机制" class="headerlink" title="TCP的流量控制机制"></a>TCP的流量控制机制</h2><p>流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<h2 id="TCP的可靠传输机制"><a href="#TCP的可靠传输机制" class="headerlink" title="TCP的可靠传输机制"></a>TCP的可靠传输机制</h2><p>基于连续 ARQ 协议和滑动窗口协议。</p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="常见的HTTP请求方法"><a href="#常见的HTTP请求方法" class="headerlink" title="常见的HTTP请求方法"></a>常见的HTTP请求方法</h2><ul>
<li>GET: 向服务器获取数据；</li>
<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>
<li>PUT：上传文件，更新数据；</li>
<li>DELETE：删除服务器上的对象；</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>
<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>
</ul>
<h2 id="GET和POST的请求"><a href="#GET和POST的请求" class="headerlink" title="GET和POST的请求"></a>GET和POST的请求</h2><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong>因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>发送的报文格式：</strong>Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>安全性：</strong>Get 请求将请求的参数放入 url 中向服务器发送，不太安全，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。</li>
<li><strong>参数类型：</strong>post 的参数传递支持更多的数据类型。</li>
</ul>
<blockquote>
<p><strong>幂等</strong>的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> ， <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a> ， <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT"><code>PUT</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE"><code>DELETE</code></a> 等方法都是<strong>幂等</strong>的，而 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST"><code>POST</code></a> 方法不是</p>
</blockquote>
<h2 id="POST和PUT请求的区别"><a href="#POST和PUT请求的区别" class="headerlink" title="POST和PUT请求的区别"></a>POST和PUT请求的区别</h2><ul>
<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为是<strong>更新数据</strong>）</li>
<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>
</ul>
<h2 id="HTTP-1-0-、1-1-和-2-0"><a href="#HTTP-1-0-、1-1-和-2-0" class="headerlink" title="HTTP 1.0 、1.1 和  2.0"></a>HTTP 1.0 、1.1 和  2.0</h2><h3 id="HTTP-1-0和-HTTP-1-1-有以下区别"><a href="#HTTP-1-0和-HTTP-1-1-有以下区别" class="headerlink" title="HTTP 1.0和 HTTP 1.1 有以下区别"></a><strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong></h3><ul>
<li><strong>连接方面</strong>，http1.0 使用非持久连接， http1.1 使用持久连接，多个 http 请求复用同一个 TCP 连接。</li>
<li><strong>资源请求方面</strong>。http1.0 中，服务器<strong>传输整个对象</strong>，<strong>不支持断点续传</strong>功能，<strong>不支持传输部分</strong>，浪费带宽；http1.1 在请求头引入了 range 头域，<strong>它允许只请求资源的某个部分</strong>，即返回码是 206（Partial Content）</li>
<li><strong>缓存方面</strong>，http1.0 缓存头 If-Modified-Since、Expires ，http1.1 则引入了<strong>更多的缓存头来控制缓存策略</strong>，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等</li>
<li>http1.1 中<strong>新增了 host 字段指定服务器的域名</strong>。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h3 id="管道网络传输和队头堵塞"><a href="#管道网络传输和队头堵塞" class="headerlink" title="管道网络传输和队头堵塞"></a><strong>管道网络传输和队头堵塞</strong></h3><p>HTTP/1.1 采用了长连接使得管道（pipeline）网络传输成为可能。</p>
<p>在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但还是得按顺序，如果前面的回应特别慢，后面就会堵。这称为队头堵塞。</p>
<p><strong>队头堵塞的解决方案：</strong></p>
<p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。</p>
<p>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>
<p><img data-src="https://ychch-blog.oss-cn-hongkong.aliyuncs.com/image-20230125205025638.webp"></p>
<h3 id="HTTP-1-1-和-HTTP-2-0-的区别"><a href="#HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="HTTP 1.1 和 HTTP 2.0 的区别"></a>HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><p><strong>二进制协议</strong>：在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个<strong>彻底的二进制协议</strong>，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。</p>
</li>
<li><p><strong>多路复用：</strong>HTTP/2 仍然复用 TCP 连接，但是实现了多路复用。在一个连接里，客户端和服务器都可以<strong>不用按照顺序同时发送多个</strong>请求或回应，这样就避免了”队头堵塞”的问题。</p>
</li>
<li><p><strong>标记数据包：</strong> HTTP/2 的数据包是不按顺序发送的，必须要对数据包做标记，指出它属于哪个请求。</p>
<p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。</p>
</li>
<li><p><strong>头信息压缩：</strong>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息，浪费带宽，影响速度。HTTP/2 引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p>
</li>
<li><p><strong>服务器推送：</strong>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，可以减少一些延迟时间。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/frankyou/p/6145485.html">HTTP 2.0 增加了对 TLS 加密的支持，提高了安全性和兼容性</a></p>
<p>HTTP/2  下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p>
</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>HTTP1.0 中默认是在每次请求/应答完成后立即断开连接，这就是<strong>短连接</strong>。</p>
<p>当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，这就是<strong>长连接</strong>。</p>
<ul>
<li>HTTP1.0版本是默认没有Keep-alive，想要保持连接，必须手动配置发送<code>Connection: keep-alive</code>，想要断开，发送<code>Connection:close</code></li>
<li>HTTP1.1 规定了默认保持长连接</li>
</ul>
<h4 id="如何建立Keep-Alive"><a href="#如何建立Keep-Alive" class="headerlink" title="如何建立Keep-Alive"></a>如何建立Keep-Alive</h4><ul>
<li>客户端向服务器在发送请求报文同时在首部添加发送<code>Connection: keep-alive</code>字段</li>
<li>服务器收到请求并处理 Connection字段，并回送<code>Connection:Keep-Alive</code>字段给客户端</li>
<li>客户端接收到Connection字段，Keep-Alive连接建立成功</li>
</ul>
<p>断开也是同理，字段换成<code>Connection:close</code></p>
<p><strong>Keep-Alive可以减少延迟，降低拥塞等优点</strong>，但值得住的是，长时间的Tcp连接容易导致系统资源无效占用，<strong>浪费系统资源</strong></p>
<h3 id="HTTP如何加载页面的多张图片？"><a href="#HTTP如何加载页面的多张图片？" class="headerlink" title="HTTP如何加载页面的多张图片？"></a>HTTP如何加载页面的多张图片？</h3><ul>
<li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li>
<li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li>
</ul>
<h3 id="HTTP2的头部压缩算法HPACK"><a href="#HTTP2的头部压缩算法HPACK" class="headerlink" title="HTTP2的头部压缩算法HPACK"></a>HTTP2的头部压缩算法HPACK</h3><p>HPACK算法：在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<ul>
<li>静态字典：由 header 字段的预定义静态列表组成。</li>
<li>动态字典：以<strong>先进先出</strong>的顺序维护的 header 字段列表</li>
<li>压缩算法：<code>Huffman哈夫曼</code> 编码</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604070508591-32d79893-7e98-40c8-b779-ffb6da42cd1b.png" alt="头部压缩算法"></p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>HTTP请求报文由4部分组成: 请求⾏ 、请求头部 、空⾏、请求体 </p>
<img data-src="https://s2.loli.net/2022/12/08/Rg5AaQuisDjmebS.png" alt="HTTP请求报文组成" style="zoom:50%;" />

<p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 </p>
<p>（2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  </p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，<a target="_blank" rel="noopener" href="http://www.example.com./">www.example.com。</a> </li>
</ul>
<p>（3）请求体: post put等请求携带的数据 </p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>响应报⽂由4部分组成: 响应⾏、 响应头、 空⾏、 响应体 </p>
<img data-src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png" alt="HTTP响应报文" style="zoom: 50%;" />

<ul>
<li>响应⾏：由<strong>网络协议版本，状态码和状态码的原因短语</strong>组成，例如 HTTP/1.1 200 OK 。 </li>
<li>响应头：响应部⾸组成 </li>
<li>响应体：服务器响应的数据 </li>
</ul>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th>原因</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p><strong>2XX 成功</strong> 请求被正常处理了</p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分。一般在服务器端不需要往客户端发送内容时使用。</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求。http1.0 还不支持；http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206</li>
</ul>
<p><strong>3XX 重定向</strong>，浏览器需要执行某些特殊的处理以正确处理请求</p>
<p><strong>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL<ul>
<li><strong>使用场景：</strong><ul>
<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>
<li>未登陆的用户访问用户中心重定向到登录页面。</li>
<li>访问404页面重新定向到首页。</li>
</ul>
</li>
</ul>
</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源<ul>
<li>303 状态码通常作为 PUT 或 POST 操作的返回结果，请求重定向页面的方法要总是使用 GET</li>
</ul>
</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端<strong>保持请求方法不变</strong>向新的地址发出请求</li>
<li>304 not modified，虽然被划分在 3XX 类别中，但是和重定向没有关系。<ul>
<li>不是一种错误，而是告诉客户端有缓存，直接用缓存数据。返回页面的只有头部信息，没有内容，这样提高了网页的性能。</li>
</ul>
</li>
</ul>
<p><strong>4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，<strong>请求报文存在语法错误</strong></li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息，当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝，不能再继续进行验证，该访问是永久禁止的</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<p><strong>5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>502 bad gateway，扮演网关或代理角色的服务器 接收的响应无效。</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h2 id="HTTP协议的优缺点"><a href="#HTTP协议的优缺点" class="headerlink" title="HTTP协议的优缺点"></a>HTTP协议的优缺点</h2><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性</p>
<p>http的优缺点不是绝对的，在某些特定情况下显示出来的优缺点，有时优点可以是缺点，有时缺点可以是优点。</p>
<p>优点：</p>
<ol>
<li>灵活可扩展，可以传输各种数据，传输类型由 Content-Type 加以标记</li>
<li>可靠，http基于tcp/ip，是一个可靠的连接</li>
<li>无状态，每次的请求和答复都是独立的，没有任何联系，可以减轻服务器的负担，对服务器无要求，因此可以组成集群。</li>
</ol>
<p>缺点：</p>
<ol>
<li><strong>无状态：</strong>HTTP 是一个无状态的协议，如果后续处理需要前面的信息，则它必须重传。cookie技术为了解决这一问题</li>
<li><strong>明文传输：</strong>协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
</ol>
<h2 id="HTTP和HTTPS协议的区别"><a href="#HTTP和HTTPS协议的区别" class="headerlink" title="HTTP和HTTPS协议的区别"></a>HTTP和HTTPS协议的区别</h2><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li><strong>安全性</strong>：HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li><strong>端口</strong>：HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image/resize,w_1500" alt="http与https的区别"></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<h2 id="TLS-SSL的工作原理"><a href="#TLS-SSL的工作原理" class="headerlink" title="TLS/SSL的工作原理"></a>TLS/SSL的工作原理</h2><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS/SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>散列函数：防止信息篡改，验证数据的完整性</li>
<li>对称加密算法：采用协商的秘钥对数据加密</li>
<li>非对称加密：实现身份认证和秘钥协商</li>
</ul>
<p><img data-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png" alt="TLS/SSL"></p>
<p>综合上述算法特点，TLS/SSL的工作方式就是<strong>客户端使用非对称加密与服务器进行通信</strong>，<strong>使用对称加密实现身份的验证</strong>。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果。</p>
<p>用于防止信息篡改并验证数据的完整性。</p>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>
<p>双方使用同一个秘钥对数据进行加密和解密，但有一个问题，如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。</p>
<p>用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。</p>
<p>掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<p><img data-src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png" alt="数字证书"></p>
<h2 id="HTTPS如何保证安全"><a href="#HTTPS如何保证安全" class="headerlink" title="HTTPS如何保证安全"></a>HTTPS如何保证安全</h2><ul>
<li>对称加密：简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题。；</li>
<li>⾮对称加密： 安全性更⾼，但是速度很慢，影响性能。 </li>
</ul>
<p>解决方案：</p>
<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 </p>
<p>这又带来一个中间人问题：</p>
<p>如果在客户端和服务器之间存在⼀个中间⼈,中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,就可以轻松解密所有数据。</p>
<p>这时候就需要第三方颁发CA，证明身份的身份，防⽌被中间⼈攻击。证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>
<p>如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 </p>
<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 </p>
<h2 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h2><ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、<strong>生成的一个随机数</strong>、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及<strong>一个服务器生成的随机数</strong>。</li>
<li><strong>客户端确认服务器证书有效后，生成一个新的随机数</strong>，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的<strong>三个随机数</strong>，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h2 id="HTTPS特点"><a href="#HTTPS特点" class="headerlink" title="HTTPS特点"></a>HTTPS特点</h2><p>优点：<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong> 记牢这三个优点就够了</p>
<p>缺点：</p>
<ol>
<li>HTTPS需要做服务器和客户端双方做加解密处理，耗费资源，过程复杂，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高</li>
<li>SSL证书需要绑定IP，不能在同一个IP上绑定多个域名</li>
</ol>
<h1 id="在浏览器中输入-Google-com-后发生了什么？"><a href="#在浏览器中输入-Google-com-后发生了什么？" class="headerlink" title="在浏览器中输入 Google.com 后发生了什么？"></a>在浏览器中输入 Google.com 后发生了什么？</h1><ol>
<li><p><strong>解析URL：</strong>对URL进行解析，分析需要用的传输协议和请求资源的路径</p>
</li>
<li><p><strong>缓存判断：</strong>浏览器判断请求的资源是否在缓存中，如果在且没有失效，直接使用，否则向服务器发起请求</p>
</li>
<li><p><strong>DNS解析：</strong>获取URL域名的IP地址，首先会判断本地是否有该域名的IP地址缓存，如果有则使用，如果没有向本地DNS服务器发起请求。本地DNS服务器检查自己是否有缓存，如果没有向根域名服务器发起请求，得到负责的顶级域名服务器地址后，再向顶级域名服务器发请求，得到权威域名服务器的地址，再向权威域名服务器发起请求，最终得到域名的IP地址。本地DNS服务器将这个ip地址返回给用户。</p>
<p>用户向本地DNS服务器的请求属于递归请求；</p>
<p>本地DNS服务器向各个域名服务器的请求属于迭代请求</p>
</li>
<li><p><strong>获取MAC地址：</strong>当得到IP地址后，还需要知道目的主机MAC地址。因为应用层下发数据给传输层，TCP协议指定端口，下发给网络层，网络层制定好ip地址，下发给数据链路层，需要通信双方的MAC地址。</p>
<p>通过ip地址与子网掩码与运算，判断主机和请求主机是否在同一个子网中，如果在同一个子网里，使用APR协议获取目的主机的MAC地址，如果不在，请求转发网关，由它代为转发，此次也可以通过ARP协议获取网关MAC地址，此次目的主机的 MAC 地址应该为网关的地址；</p>
</li>
<li><p><strong>TCP三次握手</strong>，建立TCP连接</p>
</li>
<li><p><strong>HTTPS握手：</strong>如果是HTTPS协议，则存在TLS的四次握手过程</p>
</li>
<li><p><strong>返回数据：</strong>浏览器解析数据，开始渲染页面</p>
</li>
<li><p><strong>四次挥手</strong>，中断连接</p>
</li>
</ol>
<h1 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h1><p>URL代表资源的路径地址，而URI代表资源的名称。</p>
<p>URL类似于住址，它告诉你一种寻找目标的方式(在这个例子中，是通过街道地址找到一个人)。要知道，上述定义同时也是一个URI。  </p>
<p><strong>URL是URI的一个子集</strong>，告诉我们访问网络位置的方式</p>
<p><img data-src="https://s2.loli.net/2022/10/13/uwXdpFOnlC4D5rt.png"></p>
<h2 id="域名摸索之路"><a href="#域名摸索之路" class="headerlink" title="域名摸索之路"></a>域名摸索之路</h2><p>这里介绍一下我域名摸索之路：</p>
<p>我的ychch.top域名是在腾讯云买的，DNS服务器一开始就是用的 adonis.dnspod.net  hermosa.dnspod.net 这两个，我的博客是在github.io上写的，起初通过 www CNAME ychch.github.io 解析到github主页上，但是这么做国内用户不能直接访问，所以我就换到 vercel，vercel提供免费的网站托管，国内外都可以流畅访问，我就把 ychch.top 的DNS服务器改成了vercel中的ns1.vercel-dns.com，ns2.vercel-dns.com，这一步仍然需要在 腾讯云中域名管理系统中改。</p>
<p>改完之后的任何解析操作（增加二级域名…) 就到 <a target="_blank" rel="noopener" href="https://vercel.com/dashboard/domains">vercel 控制台</a> 中去增改就好。</p>
<p><img data-src="https://s2.loli.net/2022/10/13/6inOkuYDK5FRg2P.png" alt="image-20221013222106500"></p>
<p><img data-src="https://s2.loli.net/2022/10/13/pC9ZO4gBdYjhIqR.png" alt="image-20221013222708371"></p>
<h1 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h1><p>DNS，domain name server，域名服务器，提供一种主机名到 IP 地址的转换服务。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。</p>
<p><strong>域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型</strong>.每个域名服务器不但能够进行一些域名到IP地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到IP地址的转换时，能够知道到什么地方去找其他域名服务器。</p>
<h2 id="DNS同时使用TCP和UDP协议"><a href="#DNS同时使用TCP和UDP协议" class="headerlink" title="DNS同时使用TCP和UDP协议"></a>DNS同时使用TCP和UDP协议</h2><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p>
<p>（1）在区域传输的时候使用TCP协议</p>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。</li>
</ul>
<p>（2）在域名解析的时候使用UDP协议</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器<strong>负载更低，响应更快</strong>。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
<ul>
<li><code>根域名服务器</code>用来<code>管辖顶级域(如.com)</code>， 通常它并<strong>不直接</strong>把待查询的域名直接转换成IP地址，而是<code>告诉本地域名服务器</code>下一步应当找哪个<code>顶级域名服务器</code>进行查询。</li>
<li>顶级域名服务器：管理在该顶级域名服务器注册的所有二级域名。收到DNS查询请求时,就给出相应的回答，给不出来就找下一级的权限服务器</li>
<li><code>授权域名服务器</code>总能将其管辖的<code>主机名</code>转换为该主机的<code>IP地址</code>。</li>
<li>本地域名服务器对域名系统非常重要，一个大学，一个电线联通站点等等。主机发出的DNS查询发给本地域名服务器，再由本地域名服务器代为询问。</li>
</ul>
<p>在Windows系统中配置<code>“本地连接”</code>时，就需要填写DNS地址，这个地址就是<code>本地DNS (域名服务器)的地址</code></p>
<p><img data-src="https://s2.loli.net/2022/12/15/teDAv2bXn1LhSWc.png" alt="服务器"></p>
<h2 id="DNS完整的查询过程"><a href="#DNS完整的查询过程" class="headerlink" title="DNS完整的查询过程"></a>DNS完整的查询过程</h2><ol>
<li>在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器（校园网，路由器等）</strong>，在本地域名服务器缓存中查询，如果找到返回结果，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器(互联网的主目录）</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器（.top顶级域名）</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向**权限域名服务器（ychch.top)**发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果返回给浏览器，并保存缓存便于下次使用</li>
</ol>
<h2 id="迭代查询与递归查询"><a href="#迭代查询与递归查询" class="headerlink" title="迭代查询与递归查询"></a>迭代查询与递归查询</h2><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>
</ul>
<p><strong><code>主机</code>向<code>本地域名服务器</code>的查询采用的是<code>递归</code>查询</strong>，**<code>本地域名服务器</code>向<code>根域名服务器</code>的查询采用<code>迭代</code>查询**</p>
<h2 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h2><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为（Name，Value，Type，TTL）</p>
<p>四种 Type 的值，分别是 A、NS、CNAME 和 MX ：</p>
<ul>
<li>如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<p>主机记录：</p>
<p><img data-src="https://s2.loli.net/2022/12/05/yT9ds8Rpb2mN6cL.png" alt="主机记录"></p>
<p>记录类型：</p>
<img data-src="https://s2.loli.net/2022/12/05/Kd3qCfVzD6E9QbA.png" alt="记录类型" style="zoom: 67%;" />

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>
<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>
<p><strong>WebSocket 特点的如下：</strong></p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据‘’</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<h2 id="即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h2><h3 id="短轮询的基本思路："><a href="#短轮询的基本思路：" class="headerlink" title="短轮询的基本思路："></a><strong>短轮询的基本思路：</strong></h3><p>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式<strong>本质上还是浏览器发送请求</strong>，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</p>
<p>这种方式的优点是<strong>比较简单，易于理解</strong>。缺点是这种方式由于需要不断的建立 http 连接，<strong>严重浪费了服务器端和客户端的资源</strong>。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>
<h3 id="长轮询的基本思路："><a href="#长轮询的基本思路：" class="headerlink" title="长轮询的基本思路："></a><strong>长轮询的基本思路：</strong></h3><p>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。<strong>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</strong>客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<p>长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，<strong>相比之下节约了资源</strong>。</p>
<p>长轮询的缺点在于，<strong>连接挂起也会导致资源的浪费</strong>。</p>
<h3 id="SSE-的基本思想："><a href="#SSE-的基本思想：" class="headerlink" title="SSE 的基本思想："></a><strong>SSE 的基本思想：</strong></h3><p><strong>服务器使用流信息向服务器推送信息</strong>。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个<strong>连续不断的数据流</strong>。这时，<strong>客户端不会关闭连接，会一直等着服务器发过来的新的数据流</strong>，视频播放就是这样的例子。</p>
<p>SSE 的方式是单向通信的，只能由服务器端向客户端推送信息</p>
<p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。它相对于前面两种方式来说，<strong>不需要建立过多的 http 请求，相比之下节约了资源</strong>。</p>
<h3 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h3><p>是 HTML5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。<strong>WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息</strong>。</p>
<p>使用 WebSocket 协议的缺点是在服务器端的<strong>配置比较复杂</strong>。</p>
<p>对于这四种即使通信协议，从性能的角度来看：</p>
<p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p>
<p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p>
<p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p>
<p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>ych-ch
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ychch.top/archives/2fa9840e.html" title="网络基础知识">https://ychch.top/archives/2fa9840e.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/7ebadd91.html" rel="prev" title="拒绝久坐，健康生活">
                  <i class="fa fa-chevron-left"></i> 拒绝久坐，健康生活
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/cbbc6216.html" rel="next" title="ES6教程">
                  ES6教程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-crow"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ych-ch</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">232k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:31</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        你是本站第<span id="busuanzi_value_site_uv"></span>位访客
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        本站已被浏览<span id="busuanzi_value_site_pv"></span>次
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="/lib/pangu/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://comment.ychch.top/","placeholder":"雁过留痕,欢迎交流评论(●'◡'●)","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":["nick"],"cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","emoji":["https://unpkg.com/@waline/emojis@1.0.1/weibo","https://unpkg.com/@waline/emojis@1.0.1/alus","https://unpkg.com/@waline/emojis@1.0.1/bilibili","https://unpkg.com/@waline/emojis@1.0.1/qq"],"meta":["nick","mail","link"],"login":"enable","el":"#waline-comments","libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","path":"/archives/2fa9840e.html"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>

  <script async src="/js/cursor/fireworks.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":80},"mobile":{"show":true,"scale":0.5},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
</html>
