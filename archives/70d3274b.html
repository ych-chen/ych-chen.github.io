<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="baidu-site-verification" content="code-oy2gTeqH9v" />
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/blogIcon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blogIcon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blogIcon.png">
  <link rel="mask-icon" href="/images/blogIcon.png" color="#222">
  <link rel="manifest" href="/images/blogIcon.png">
  <meta name="google-site-verification" content="5O1JD7i07BBNtPS8GeMREfy3KlJKyIHRvUbt0Ulnc4k">
  <meta name="msvalidate.01" content="defbadb89c5687f86ead63be53a1b83c">
  <meta name="baidu-site-verification" content="kBCDbEEWrIWKXwYW">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/lib/@fortawesome/fontawesome-free/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/animate.css/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="/lib/pace-js/themes/blue/pace-theme-minimal.css">
  <script src="/lib/pace-js/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"ychch.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="背八股过程中，做一些精简记录，不定期更新。 比较全的前端框架知识 见以前的博文。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端VUE知识点汇总">
<meta property="og:url" content="https://ychch.top/archives/70d3274b.html">
<meta property="og:site_name" content="CYC&#39;s 个人博客">
<meta property="og:description" content="背八股过程中，做一些精简记录，不定期更新。 比较全的前端框架知识 见以前的博文。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/02/10/82aUMNwB6TYWEp3.png">
<meta property="article:published_time" content="2023-02-09T19:37:06.000Z">
<meta property="article:modified_time" content="2024-08-20T01:47:49.051Z">
<meta property="article:author" content="ych-ch">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/02/10/82aUMNwB6TYWEp3.png">


<link rel="canonical" href="https://ychch.top/archives/70d3274b.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ychch.top/archives/70d3274b.html","path":"archives/70d3274b.html","title":"前端VUE知识点汇总"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端VUE知识点汇总 | CYC's 个人博客</title>
  




<link rel="dns-prefetch" href="https://comment.ychch.top/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="CYC's 个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CYC's 个人博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">当我与世界初相见</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>我 & 友链</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">58</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">60</span></a></li>
        <li class="menu-item menu-item-pictures"><a href="/gallery/" rel="section"><i class="fa fa-images fa-fw"></i>影像馆</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-video fa-fw"></i>光影岁月</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>好书推荐</a></li>
        <li class="menu-item menu-item-shuoshuo"><a href="/shuoshuo/" rel="section"><i class="fa fa-comment fa-fw"></i>只言片语</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#vue"><span class="nav-number">1.</span> <span class="nav-text">vue</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue"><span class="nav-number">1.1.</span> <span class="nav-text">Vue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">双向绑定原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vue2"><span class="nav-number">1.2.1.</span> <span class="nav-text">vue2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue3"><span class="nav-number">1.2.2.</span> <span class="nav-text">Vue3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-%E5%8F%AA%E4%BC%9A%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AC%AC%E4%B8%80%E5%B1%82%EF%BC%8C%E9%82%A3%E4%B9%88-Vue3-%E5%8F%88%E6%98%AF%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">1.3.</span> <span class="nav-text">虚拟DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">1.3.1.</span> <span class="nav-text">如何理解虚拟DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">虚拟DOM的解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">1.3.3.</span> <span class="nav-text">为什么使用虚拟DOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">diff算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A2%E7%84%B6-Vue-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8F%AF%E4%BB%A5%E7%B2%BE%E5%87%86%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM-%E8%BF%9B%E8%A1%8C-diff-%E7%9B%91%E6%B5%8B%E5%B7%AE%E5%BC%82-%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pull"><span class="nav-number">1.5.1.</span> <span class="nav-text">pull</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#push"><span class="nav-number">1.5.2.</span> <span class="nav-text">push</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E7%B1%BB%E4%BC%BC%E4%BA%8E-React-%E4%B8%AD-shouldComponentUpdate-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setup"><span class="nav-number">1.7.</span> <span class="nav-text">setup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.8.</span> <span class="nav-text">生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">父子组件中生命周期的调用顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="nav-number">1.9.</span> <span class="nav-text">添加响应式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reactive"><span class="nav-number">1.9.1.</span> <span class="nav-text">reactive</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F"><span class="nav-number">1.10.</span> <span class="nav-text">样式穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ref-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.11.</span> <span class="nav-text">ref 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84Vue%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.12.</span> <span class="nav-text">说一下常用的Vue修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84header%E7%BB%84%E4%BB%B6"><span class="nav-number">1.13.</span> <span class="nav-text">移动端如何实现一个常见的header组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-on%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E5%90%97"><span class="nav-number">1.14.</span> <span class="nav-text">v-on可以实现监听多个方法吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%E4%BD%86%E5%8F%AA%E6%9B%B4%E6%96%B0%E4%B8%80%E6%AC%A1"><span class="nav-number">1.15.</span> <span class="nav-text">vue数据为什么频繁变化但只更新一次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.16.</span> <span class="nav-text">插槽和作用域插槽的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E4%B8%AD%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%8A%BD%E7%A6%BB%EF%BC%9F"><span class="nav-number">1.17.</span> <span class="nav-text">vue中相同逻辑如何进行抽离？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E5%BC%82%E6%AD%A5%E6%B8%B2%E6%9F%93"><span class="nav-number">1.18.</span> <span class="nav-text">vue为什么采用异步渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nextTick%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">1.19.</span> <span class="nav-text">$nextTick原理及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-if%E3%80%81v-show"><span class="nav-number">1.20.</span> <span class="nav-text">v-if、v-show</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model"><span class="nav-number">1.21.</span> <span class="nav-text">v-model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#keep-alive"><span class="nav-number">1.22.</span> <span class="nav-text">keep-alive</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#VueRouter"><span class="nav-number">2.</span> <span class="nav-text">VueRouter</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#hash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">hash模式和history模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#router%E5%92%8Croute%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.</span> <span class="nav-text">router和route区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.3.</span> <span class="nav-text">路由懒加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">对前端路由的理解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vuex"><span class="nav-number">3.</span> <span class="nav-text">Vuex</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ych-ch"
      src="/images/bird-in-snow.webp">
  <p class="site-author-name" itemprop="name">ych-ch</p>
  <div class="site-description" itemprop="description">个人博客</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ych-chen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ych-chen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2021206190014@whu.edu.cn" title="E-Mail → mailto:2021206190014@whu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>



        </div>
      </div>

+     <div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>     
 
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ychch.top/archives/70d3274b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/bird-in-snow.webp">
      <meta itemprop="name" content="ych-ch">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CYC's 个人博客">
      <meta itemprop="description" content="个人博客">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="前端VUE知识点汇总 | CYC's 个人博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端VUE知识点汇总
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-10 03:37:06" itemprop="dateCreated datePublished" datetime="2023-02-10T03:37:06+08:00">2023-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-20 09:47:49" itemprop="dateModified" datetime="2024-08-20T09:47:49+08:00">2024-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">前端开发</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/archives/70d3274b.html#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/archives/70d3274b.html" data-xid="/archives/70d3274b.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>背八股过程中，做一些精简记录，不定期更新。</p>
<p>比较全的前端框架知识 见以前的博文。</p>
<span id="more"></span>

<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>一个构建数据驱动的渐进式框架，关于 <em>Vue</em> 的优点，主要有<strong>响应式编程、组件化开发、虚拟 DOM</strong></p>
<p>响应式编程：通过 <em>MVVM</em> 思想实现数据的双向绑定</p>
<p>组件化开发：将应用各模块拆分到各组件中，提高开发效率、方便重复使用…</p>
<p>虚拟 DOM：传统开发中，jQuery或原生DOM操作会导致浏览器不断渲染DOM树，性能开销大；虚拟 <em>DOM</em> 将各种操作放在虚拟节点中，计算完毕后才统一提交。</p>
<h2 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h2><h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3><p><img data-src="https://s2.loli.net/2023/02/10/82aUMNwB6TYWEp3.png"></p>
<p>采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为：</p>
<ol>
<li>需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li>
<li>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁</li>
<li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</li>
</ol>
<h3 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h3><p><em>Vue 3.0</em> 中采用了 <em>Proxy</em>，抛弃了 <em>Object.defineProperty</em> 方法</p>
<ol>
<li><em>Object.defineProperty</em> 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应</li>
<li><em>Object.defineProperty</em> 只能劫持对象的属性,需要对每个对象，每个属性进行遍历; <em>Proxy</em> 可以劫持整个对象，并返回一个新的对象</li>
<li><em>Proxy</em> 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li>
<li>多达 <em>13</em> 种拦截方法，作为新标准是趋势</li>
</ol>
<h3 id="Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？"><a href="#Proxy-只会代理对象的第一层，那么-Vue3-又是怎样处理这个问题的呢？" class="headerlink" title="Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？"></a>Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？</h3><p>判断当前 <em>Reflect.get</em> 的返回值是否为 <em>Object</em>，如果是则再通过 <em>reactive</em> 方法做代理， 这样就实现了深度观测。</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><h3 id="如何理解虚拟DOM"><a href="#如何理解虚拟DOM" class="headerlink" title="如何理解虚拟DOM"></a>如何理解虚拟DOM</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。</p>
<p>将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。</p>
<p>通过<strong>事务处理机制</strong>，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<h3 id="虚拟DOM的解析过程"><a href="#虚拟DOM的解析过程" class="headerlink" title="虚拟DOM的解析过程"></a>虚拟DOM的解析过程</h3><ul>
<li>对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li>
<li>当页面的状态发生改变，需要对页面 DOM 结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li>
<li>最后将有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>
</ul>
<h3 id="为什么使用虚拟DOM"><a href="#为什么使用虚拟DOM" class="headerlink" title="为什么使用虚拟DOM"></a>为什么使用虚拟DOM</h3><ol>
<li>提升性能</li>
</ol>
<p>如果渲染使用真实DOM，由于真实DOM的各项操作会带来大量性能损耗，极大降低渲染效率。使用虚拟 dom ，主要为解决渲染效率的问题。</p>
<ul>
<li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li>
<li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li>
</ul>
<p><strong>虚拟DOM保证性能下限，提供过得去的性能</strong></p>
<ol start="2">
<li>跨平台</li>
</ol>
<p>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p>
<h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>当组件创建和更新时，vue 均会执行内部的 update 函数，该函数使用 render 函数生成的虚拟 dom 树，将新旧两树进行对比，找到差异点，最终更新到真实 dom</p>
<p>对比差异的过程叫 diff，vue 在内部通过一个叫 patch 的函数完成该过程</p>
<p>在对比时，vue 采用<strong>深度优先、同层比较</strong>的方式进行比对。</p>
<p>在判断两个节点是否相同时，vue 是通过<strong>虚拟节点的 key 和 tag</strong>来进行判断</p>
<h2 id="既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？"><a href="#既然-Vue-通过数据劫持可以精准探测数据变化，为什么还需要虚拟-DOM-进行-diff-监测差异-？" class="headerlink" title="既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？"></a>既然 Vue 通过数据劫持可以精准探测数据变化，为什么还需要虚拟 DOM 进行 diff 监测差异 ？</h2><p>现代前端框架有两种方式侦测变化，一种是 <em>pull</em>，一种是 <em>push</em>。</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>其代表为 <em>React</em>，我们可以回忆一下 <em>React</em> 是如何侦测到变化的。</p>
<p>我们通常会用 <em>setState API</em> 显式更新,然后 <em>React</em> 会进行一层层的 <em>Virtual Dom Diff</em> 操作找出差异，然后 <em>Patch</em> 到 <em>DOM</em> 上，<em>React</em> 从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的 <em>Diff</em> 操作查找「哪发生变化了」</p>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a><strong>push</strong></h3><p><em>Vue</em> 的响应式系统则是 <em>push</em> 的代表，当 <em>Vue</em> 程序初始化的时候就会对数据 <em>data</em> 进行依赖的收集，一但数据发生变化，响应式系统就会立刻得知，因此 <em>Vue</em> 是一开始就知道是「在哪发生变化了」</p>
<p>这又会产生一个问题，通常绑定一个数据就需要一个 <em>Watcher</em>，一但我们的绑定细粒度过高就会产生大量的 <em>Watcher</em>，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化，因此 <em>Vue</em> 的设计是选择中等细粒度的方案，<strong>在组件级别进行 <em>push</em> 侦测</strong>的方式</p>
<p><strong>通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行 <em>Virtual Dom Diff</em> 获取更加具体的差异，而 <em>Virtual Dom Diff</em> 则是 <em>pull</em> 操作，<em>Vue</em> 是 <em>push + pull</em> 结合的方式进行变化侦测的。</strong></p>
<h2 id="Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？"><a href="#Vue-为什么没有类似于-React-中-shouldComponentUpdate-的生命周期？" class="headerlink" title="Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？"></a>Vue 为什么没有类似于 React 中 shouldComponentUpdate 的生命周期？</h2><p>根本原因是 <em>Vue</em> 与 <em>React</em> 的变化侦测方式有所不同</p>
<p><em>React</em> 是 <em>pull</em> 的方式侦测变化，当 <em>React</em> 知道发生变化后，会使用 <em>Virtual Dom Diff</em> 进行差异检测,但是很多组件实际上是肯定不会发生变化的，这个时候<strong>需要用 <em>shouldComponentUpdate</em> 进行手动操作来减少 <em>diff</em></strong>，从而提高程序整体的性能。</p>
<p><em>Vue</em> 是 <em>pull+push</em> 的方式侦测变化的，在一开始就知道那个组件发生了变化，因此在 <em>push</em> 的阶段并不需要手动控制 <em>diff</em>，而组件内部采用的 <em>diff</em> 方式实际上是可以引入类似于 <em>shouldComponentUpdate</em> 相关生命周期的，但是**通常合理大小的组件不会有过量的 <em>diff</em>，手动优化的价值有限**，因此目前 <em>Vue</em> 并没有考虑引入 <em>shouldComponentUpdate</em> 这种手动优化的生命周期。</p>
<h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>给 <code>script</code> 标签附上 <code>setup</code> 属性后，内部将不再通过 <code>export default</code> 抛出方式的语法。<code>template</code> 模板可以直接拿到 <code>script</code> 标签内声明的变量，并且支持响应式</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>对于 <em>vue</em> 来讲，生命周期就是一个 <em>vue</em> 实例从创建到销毁的过程。</p>
<p>通俗的说，<em>hook</em> 就是在程序运行中，在某个特定的位置，框架的开发者设计好了一个钩子来告诉我们当前程序已经运行到特定的位置了，会触发一个回调函数，并提供给我们，让我们可以在生命周期的特定阶段进行相关业务代码的编写</p>
<p>先看看生命周期的对照表：</p>
<table>
<thead>
<tr>
<th>Vue 2.0</th>
<th>Vue3</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>setup()</td>
<td></td>
</tr>
<tr>
<td>created</td>
<td>setup()</td>
<td>创建<code>data</code> 和 <code>method</code></td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount</td>
<td>组件挂载前执行的函数</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted</td>
<td>组件挂载后的函数</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
<td>更新前</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated</td>
<td>更新后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>onBeforeUnmount</td>
<td>卸载前</td>
</tr>
<tr>
<td>destroyed</td>
<td>onUnmounted</td>
<td>卸载后</td>
</tr>
<tr>
<td>activated</td>
<td>onActivated</td>
<td>被 <code>keep-alive</code> 缓存的组件激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>onDeactivated</td>
<td>被 keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
<td>捕获来自子孙组件的异常时激活钩子函数</td>
</tr>
</tbody></table>
<p><code>setup</code> 调用的时机是创建组件实例，然后初始化 <code>props</code>，紧接着就是调用 <code>setup</code> 函数。在 <code>beforeCreate</code> 钩子之前被调用，所以 <code>setup</code> 内是拿不到 <code>this</code> 上下文的。</p>
<p>vue3中，除去 <code>beforeCreate</code> 和 <code>created</code> 之外，有 9 个旧的生命周期钩子，我们可以在 <code>setup</code> 方法中访问</p>
<h3 id="父子组件中生命周期的调用顺序"><a href="#父子组件中生命周期的调用顺序" class="headerlink" title="父子组件中生命周期的调用顺序"></a><strong>父子组件中生命周期的调用顺序</strong></h3><ul>
<li>加载渲染过程：父<em>beforeCreate</em>-&gt;父<em>created</em>-&gt;父<em>beforeMount</em>-&gt;子<em>beforeCreate</em>-&gt;子<em>created</em>-&gt;子<em>beforeMount</em>- &gt;子<em>mounted</em>-&gt;父<em>mounted</em></li>
<li>子组件更新过程：父<em>beforeUpdate</em>-&gt;子<em>beforeUpdate</em>-&gt;子<em>updated</em>-&gt;父<em>updated</em></li>
<li>父组件更新过程：父 <em>beforeUpdate</em> -&gt; 父 <em>updated</em></li>
<li>销毁过程：父<em>beforeDestroy</em>-&gt;子<em>beforeDestroy</em>-&gt;子<em>destroyed</em>-&gt;父 destroyed</li>
</ul>
<h2 id="添加响应式"><a href="#添加响应式" class="headerlink" title="添加响应式"></a>添加响应式</h2><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 接收一个 JS 对象 作为参数，返回一个该对象的proxy代理，允许多层嵌套</p>
<ul>
<li><p>JS 对象为 对象、数组和 <code>Map</code>、<code>Set</code> 这样的集合类型，而对 <code>string</code>、<code>number</code> 和 <code>boolean</code> 这样的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">原始类型</a> 无效</p>
</li>
<li><p>不可以随意地“替换”一个响应式对象，不可以将响应式对象的属性赋值或解构</p>
</li>
</ul>
<h2 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h2><p>需要使用 scoped 属性 保证组件间不会样式污染，但是有时候需要做样式穿透，有这么几种方式：</p>
<ol>
<li>深度选择器  ::deep()</li>
<li>在 <em>vue</em> 组件中定义一个全局的 <em>style</em> 标签，一个含有作用域的 <em>style</em> 标签</li>
</ol>
<h2 id="ref-的作用"><a href="#ref-的作用" class="headerlink" title="ref 的作用"></a>ref 的作用</h2><p><em>ref</em> 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <em>$refs</em> 对象上。其特点是：</p>
<ul>
<li>如果在普通的 <em>DOM</em> 元素上使用，引用指向的就是 <em>DOM</em> 元素</li>
<li>如果用在子组件上，引用就指向组件实例</li>
</ul>
<p>常见的使用场景有：</p>
<ol>
<li>基本用法，本页面获取 <em>DOM</em> 元素</li>
<li>获取子组件中的 <em>data</em></li>
<li>调用子组件中的方法</li>
</ol>
<h2 id="说一下常用的Vue修饰符"><a href="#说一下常用的Vue修饰符" class="headerlink" title="说一下常用的Vue修饰符"></a>说一下常用的Vue修饰符</h2><ul>
<li>事件修饰符<ul>
<li><em>.stop</em>：阻止冒泡。</li>
<li><em>.prevent</em>：阻止默认事件。</li>
<li><em>.capture</em>：使用事件捕获模式。</li>
<li><em>.self</em>：只在当前元素本身触发。</li>
<li><em>.once</em>：只触发一次。</li>
</ul>
</li>
<li>按键修饰符<ul>
<li>.<em>enter</em>：回车</li>
<li>.<em>tab</em>：制表键</li>
<li>.<em>delete</em>：捕获 “删除” 和 “退格” 键</li>
<li>.<em>esc</em>：返回</li>
<li>.<em>space</em>：空格</li>
</ul>
</li>
<li>表单修饰符<ul>
<li>.<em>lazy</em>：在文本框失去焦点时才会渲染</li>
<li>.<em>number</em>：将文本框中所输入的内容转换为 number 类型</li>
<li>.<em>trim</em>：可以自动过滤输入首尾的空格</li>
</ul>
</li>
</ul>
<h2 id="移动端如何实现一个常见的header组件"><a href="#移动端如何实现一个常见的header组件" class="headerlink" title="移动端如何实现一个常见的header组件"></a>移动端如何实现一个常见的header组件</h2><p>header组件一般分为 左右中 三部分。中间为主标题，可以通过vue props方式做成可配置向外暴露，左右两侧可以通过 <em>vue slot</em> 插槽的方式对外暴露以实现多样化，同时也可以提供 <em>default slot</em> 默认插槽来统一页面风格。</p>
<h2 id="v-on可以实现监听多个方法吗"><a href="#v-on可以实现监听多个方法吗" class="headerlink" title="v-on可以实现监听多个方法吗"></a>v-on可以实现监听多个方法吗</h2><p>可以，几种写法：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js">写法一：
<span class="token operator">&lt;</span>div v<span class="token operator">-</span>on<span class="token operator">=</span><span class="token string">"&#123; 事件类型: 事件处理函数, 事件类型: 事件处理函数 &#125;"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
写法二：
<span class="token operator">&lt;</span>div @事件类型<span class="token operator">=</span><span class="token string">"“事件处理函数”"</span> @事件类型<span class="token operator">=</span><span class="token string">"“事件处理函数”"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
写法三：在一个事件里面书写多个事件处理函数
<span class="token operator">&lt;</span>div @事件类型<span class="token operator">=</span><span class="token string">"“事件处理函数1，事件处理函数2”"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
写法四：在事件处理函数内部调用其他的函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="vue数据为什么频繁变化但只更新一次"><a href="#vue数据为什么频繁变化但只更新一次" class="headerlink" title="vue数据为什么频繁变化但只更新一次"></a>vue数据为什么频繁变化但只更新一次</h2><p><em>DOM</em> 更新是一个异步操作，在数据更新后会首先被 <em>set</em> 钩子监听到，但是不会马上执行 <em>DOM</em> 更新，而是在下一轮循环中执行更新。</p>
<p><em>具体实现是vue</em> 中实现了一个 <em>queue</em> 队列用于存放本次事件循环中的所有 <em>watcher</em> 更新，并且同一个 <em>watcher</em> 的更新只会被推入队列一次。在本轮事件循环的微任务执行结束后执行此更新，这就是 <em>DOM</em> 只会更新一次的原因。</p>
<p>在下一个的事件循环“<em>tick</em>”中，<em>vue</em> 刷新队列并执行实际 (已去重的) 工作。<em>vue</em> 在内部对异步队列尝试使用原生的 <em>Promise.then、MutationObserver</em>  和 <em>setImmediate</em>，如果执行环境不支持，则会采用 <em>setTimeout(fn, 0)</em> 代替。</p>
<h2 id="插槽和作用域插槽的区别"><a href="#插槽和作用域插槽的区别" class="headerlink" title="插槽和作用域插槽的区别"></a>插槽和作用域插槽的区别</h2><p>插槽的作用是子组件提供了可替换模板，父组件可以更换模板的内容。</p>
<p>作用域插槽给了子组件将数据返给父组件的能力，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。<strong>本质是子组件可以通过插槽的位置绑定一些数据，让父组件插槽位置可以用这个数据。</strong></p>
<h2 id="vue中相同逻辑如何进行抽离？"><a href="#vue中相同逻辑如何进行抽离？" class="headerlink" title="vue中相同逻辑如何进行抽离？"></a>vue中相同逻辑如何进行抽离？</h2><p>vue2 中采用混入（<em>mixin</em>）技术。</p>
<p>vue3 中采用组合式函数，组合式函数(Composables) 是一个利用 Vue 的组合式 API 来封装和复用<strong>有状态逻辑</strong>的函数。</p>
<h2 id="vue为什么采用异步渲染"><a href="#vue为什么采用异步渲染" class="headerlink" title="vue为什么采用异步渲染"></a>vue为什么采用异步渲染</h2><p>如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染；为了性能考虑，<em>Vue</em> 会在本轮数据更新后，再去异步更新视图</p>
<p>异步渲染的原理</p>
<ol>
<li>调用 <em>notify( )</em> 方法，通知 <em>watcher</em> 进行更新操作</li>
<li>依次调用 watcher 的 update 方法</li>
<li>对 watcher 进行去重操作（通过 id）放到队列里</li>
<li>执行完后异步清空这个队列，nextTick（flushSchedulerQueue）进行批量更新操作</li>
</ol>
<h2 id="nextTick原理及作用"><a href="#nextTick原理及作用" class="headerlink" title="$nextTick原理及作用"></a>$nextTick原理及作用</h2><p>nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>
<p>两种情况用到：</p>
<ol>
<li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中；</li>
<li>在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，没办法操作DOM，所以必须将代码放在<code>nextTick()</code>的回调函数中</li>
</ol>
<h2 id="v-if、v-show"><a href="#v-if、v-show" class="headerlink" title="v-if、v-show"></a>v-if、v-show</h2><ul>
<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li>
</ul>
<p>两者区别：</p>
<ul>
<li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>
<li><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>
<li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
<li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>
</ul>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model 实际上是一个语法糖</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"searchText"</span><span class="token operator">></span> 
全等于
<span class="token operator">&lt;</span>input
  v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">"searchText"</span>
  v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">"searchText = $event.target.value"</span>
<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>适用于<strong>表单元素、组件</strong></p>
<p>如何理解v-model用在组件上，自定义组件和父组件的交互如下：</p>
<ol>
<li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>
<li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>
</ol>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>在组件切换的时候，保存一些组件的状态防止多次渲染，可以使用 keep-alive 组件包裹需要保存的组件。</p>
<h1 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h1><h2 id="hash模式和history模式"><a href="#hash模式和history模式" class="headerlink" title="hash模式和history模式"></a>hash模式和history模式</h2><p><code>#</code> 后面 <em>hash</em> 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面；</p>
<p>通过监听 <em>hashchange</em> 事件可以知道 <em>hash</em> 发生了哪些变化，然后根据 <em>hash</em> 变化来实现更新页面部分内容的操作。</p>
<p><em>history</em> 模式的实现，主要是 <em>HTML5</em> 标准发布的两个 <em>API</em>，<em>pushState</em> 和 <em>replaceState</em>，这两个 <em>API</em> 可以 <strong>改变url但又不刷新页面</strong>的效果。这样就可以监听 <em>url</em> 变化来实现更新页面部分内容的操作。</p>
<p>两者区别：</p>
<ul>
<li>首先是在 <em>URL</em> 的展示上，<em>hash</em> 模式有“#”，<em>history</em> 模式没有</li>
<li>刷新页面时，<em>hash</em> 模式可以正常加载到 <em>hash</em> 值对应的页面，而 <em>history</em> 没有处理的话，会返回 <em>404</em>，一般需要后端将所有页面都配置重定向到首页路由</li>
<li>在兼容性上，<em>hash</em> 可以支持低版本浏览器和 <em>IE</em></li>
</ul>
<h2 id="router和route区别"><a href="#router和route区别" class="headerlink" title="router和route区别"></a>router和route区别</h2><ul>
<li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name ，component等路由信息参数</li>
<li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>
</ul>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>延迟加载，即在需要的时候进行加载，随用随载</p>
<p>如果能把不同路由对应的组件分割成不同的代码块，当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>非懒加载：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">"@/components/list.vue"</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/list"</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>懒加载：</p>
<pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">"@/components/list.vue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">"/list"</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> List <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对前端路由的理解"><a href="#对前端路由的理解" class="headerlink" title="对前端路由的理解"></a>对前端路由的理解</h2><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p>
<p>Ajax 出现了，它允许人们在不刷新页面的情况下发起请求。与之共生的，还有不刷新页面即可更新页面内容这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p>
<p>在 SPA 诞生之初，在内容切换前后，页面的 URL 都是一样的，这就有两个问题：</p>
<ul>
<li>SPA 其实并不知道当前的页面“进展到了哪一步，一次刷新，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位</li>
<li>有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，收集信息不全</li>
</ul>
<p>为了解决这个问题，前端路由出现了</p>
<p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p>
<p>如何实现呢：</p>
<ol>
<li>拦截用户的刷新操作，因为一旦刷新就重新请求资源，就重来了，要把刷新这个动作完全放到前端逻辑里消化掉。</li>
<li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。我们可以给它做一些微小的处理，根据后续感知到的变化，用 JS 去给它生成不同的内容。</li>
</ol>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p>
<p>待续…</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>ych-ch
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://ychch.top/archives/70d3274b.html" title="前端VUE知识点汇总">https://ychch.top/archives/70d3274b.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag"># 前端</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/66bfc408.html" rel="prev" title="2023总结与新年展望">
                  <i class="fa fa-chevron-left"></i> 2023总结与新年展望
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/62403f8d.html" rel="next" title="JavaScript概念辨析">
                  JavaScript概念辨析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-crow"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ych-ch</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">232k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:31</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        你是本站第<span id="busuanzi_value_site_uv"></span>位访客
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        本站已被浏览<span id="busuanzi_value_site_pv"></span>次
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="/lib/animejs/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="/lib/@next-theme/pjax/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="/lib/medium-zoom/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
  <script src="/lib/lozad/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="/lib/pangu/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="/lib/hexo-generator-searchdb/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://comment.ychch.top/","placeholder":"雁过留痕,欢迎交流评论(●'◡'●)","avatar":"mm","pageSize":10,"visitor":false,"comment_count":false,"requiredFields":["nick"],"meta":["nick","mail","link"],"libUrl":"//cdn.jsdelivr.net/npm/@waline/client","el":"#waline-comments","path":"/archives/70d3274b.html"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>

  <script async src="/js/cursor/fireworks.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":80},"mobile":{"show":true,"scale":0.5},"dialog":{"enable":true,"hitokoto":true},"log":false});</script></body>
</html>
